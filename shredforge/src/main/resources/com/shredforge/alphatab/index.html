<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AlphaTab Host</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #1e1f22;
        color: #e6e6e6;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        font-size: 13px;
      }
      #root {
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
      }
      #at-controls {
        box-sizing: border-box;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        background: #1b1c1f;
        border-bottom: 1px solid #2b2c30;
      }
      #at-controls button,
      #at-controls input[type='range'] {
        cursor: pointer;
      }
      .at-btn {
        padding: 4px 10px;
        border-radius: 4px;
        border: 1px solid #3a3b40;
        background: #2a2b30;
        color: #e6e6e6;
      }
      .at-btn:hover {
        background: #35363c;
      }
      .at-btn:disabled {
        opacity: 0.5;
        cursor: default;
      }
      #at-playback-progress {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 4px;
        border-radius: 999px;
        background: #2d2e33;
      }
      #at-playback-progress::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #f8c555;
        margin-top: -3px;
      }
      #at-playback-progress::-moz-range-thumb {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #f8c555;
      }
      #at-tempo {
        width: 100px;
      }
      #at-track-select {
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #3a3b40;
        background: #2a2b30;
        color: #e6e6e6;
        font-size: 13px;
        max-width: 200px;
      }
      #at-track-select:disabled {
        opacity: 0.5;
      }
      #at-tempo-label {
        min-width: 40px;
        text-align: right;
      }
      #at-container {
        flex: 1 1 auto;
        min-height: 0;
      }
      #at {
        width: 100%;
        height: 100%;
        overflow: auto;
      }
      /* AlphaTab built-in player visuals */
      #at svg .at-selection {
        fill: rgba(255, 240, 160, 0.7);
      }
      #at .at-cursor-bar {
        background: rgba(64, 64, 255, 0.75);
        width: 3px;
      }
      #at .at-cursor-beat {
        background: rgba(64, 64, 255, 0.75);
        width: 3px;
      }
      #at svg .at-highlight {
        fill: #ffca6f;
        stroke: #ffca6f;
      }
      /* Fallback: force text to white in case attribute-based recolor misses something */
      #at svg text {
        fill: #ffffff !important;
      }
      .hidden {
        display: none;
      }
    </style>
    <script>
      (function () {
        function load(src, onload) {
          var s = document.createElement('script');
          s.src = src;
          s.onload = onload;
          s.onerror = function () {
            onload(true);
          };
          document.head.appendChild(s);
        }
        // Try local first as required; fall back to CDN if missing
        load('alphatab.js', function (err) {
          if (err || !window.alphaTab) {
            load('https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.6.0/dist/alphaTab.js', function () {});
          }
        });
      })();
    </script>
    <script src="alphatab.wasm"></script>
  </head>
  <body>
    <div id="root">
      <div id="at-controls">
        <button id="at-play-pause" class="at-btn" disabled>Play</button>
        <button id="at-restart" class="at-btn" disabled>Restart</button>
        <select id="at-track-select" disabled>
          <option value="">No track loaded</option>
        </select>
        <div style="flex: 1 1 auto"></div>
        <span id="at-status" style="font-size: 11px; opacity: 0.8"></span>
        <label for="at-tempo">Tempo</label>
        <input id="at-tempo" type="range" min="0.5" max="1.5" step="0.05" value="1.0" />
        <span id="at-tempo-label">1.0x</span>
      </div>
      <div id="at-container">
        <div id="at"></div>
      </div>
    </div>
    <script>
      let api = null;
      let playerDurationMs = 0;
      let playerPositionMs = 0;
      let playerReady = false;

      function ensureApi() {
        if (api) return api;
        const el = document.getElementById('at');
        if (!window.alphaTab || !window.alphaTab.AlphaTabApi) {
          el.innerHTML = '<div style="padding:12px">AlphaTab library not loaded.</div>';
          return null;
        }
        // Use soundfont URL from Java (injected as window.javaSoundFontUrl), or fall back to CDN
        const sfUrl = window.javaSoundFontUrl || 'https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.6.0/dist/soundfont/sonivox.sf2';
        const sfLen = sfUrl ? sfUrl.length : 0;
        console.log('Creating AlphaTab API with soundfont length:', sfLen, 'isDataUrl:', sfUrl.startsWith('data:'));
        api = new window.alphaTab.AlphaTabApi(el, {
          engine: 'svg',
          player: {
            enablePlayer: true,
            soundFont: sfUrl,
            scrollElement: document.getElementById('at-container'),
          },
          // Tabs-only, rhythm below, and force white resources (per alphaTab discussion #1558)
          display: {
            staveProfile: 'Tab',
            resources: {
              staffLineColor: '#dddddd',
              barSeparatorColor: '#dddddd',
              mainGlyphColor: '#dddddd',
              secondaryGlyphColor: '#dddddd',
              scoreInfoColor: '#dddddd',
              barNumberColor: '#dddddd',
            },
          },
          tablature: { rhythm: { position: 'Below' } },
        });
        if (api.renderFinished && api.renderFinished.on) {
          api.renderFinished.on(() => {
            const svgEl = el.querySelector('svg');
            normalizeArcOrientation(svgEl);
            const svg = svgEl ? svgEl.outerHTML : '';
            if (window.javaConnector && window.javaConnector.onSvgReady) {
              try {
                window.javaConnector.onSvgReady(svg);
              } catch (e) {
                /* ignored */
              }
            }
          });
        }

        try {
          setupPlayerBindings(api);
        } catch (e) {
          /* ignore player binding errors */
        }

        // Listen for player ready event
        if (api.playerReady && api.playerReady.on) {
          api.playerReady.on(() => {
            playerReady = true;
            const statusLabel = document.getElementById('at-status');
            if (statusLabel) statusLabel.textContent = 'Player ready';
            console.log('AlphaTab player ready');
          });
        }

        // Listen for soundfont load progress events
        if (api.soundFontLoad && api.soundFontLoad.on) {
          api.soundFontLoad.on((e) => {
            const pct = e && e.total ? Math.floor((e.loaded / e.total) * 100) : 0;
            console.log('SoundFont loading:', pct + '%', e);
            const statusLabel = document.getElementById('at-status');
            if (statusLabel && !playerReady) {
              statusLabel.textContent = 'Loading soundfont: ' + pct + '%';
            }
          });
        }

        // Listen for errors
        if (api.error && api.error.on) {
          api.error.on((e) => {
            console.error('AlphaTab error:', e);
            const statusLabel = document.getElementById('at-status');
            if (statusLabel) {
              statusLabel.textContent = 'Error: ' + (e && e.message ? e.message : e);
            }
          });
        }

        // Listen for score loaded event
        if (api.scoreLoaded && api.scoreLoaded.on) {
          api.scoreLoaded.on((score) => {
            console.log('Score loaded:', score ? score.title : 'unknown');
            populateTrackSelector(score);
          });
        }

        // Listen for MIDI load events (important for playback)
        if (api.midiLoad && api.midiLoad.on) {
          api.midiLoad.on((e) => {
            console.log('MIDI loading:', e);
          });
        }

        if (api.midiLoaded && api.midiLoaded.on) {
          api.midiLoaded.on(() => {
            console.log('MIDI loaded - playback should work now');
          });
        }

        return api;
      }

      /**
       * Populates the track selector dropdown with tracks from the loaded score.
       */
      function populateTrackSelector(score) {
        const select = document.getElementById('at-track-select');
        if (!select) return;

        // Clear existing options
        select.innerHTML = '';

        if (!score || !score.tracks || score.tracks.length === 0) {
          select.innerHTML = '<option value="">No tracks available</option>';
          select.disabled = true;
          return;
        }

        // Add an option for each track
        score.tracks.forEach((track, index) => {
          const option = document.createElement('option');
          option.value = index;
          // Build track name: use track name, or instrument name, or fallback
          let trackName = track.name || '';
          if (!trackName && track.playbackInfo) {
            // Try to get instrument name from MIDI program
            trackName = 'Track ' + (index + 1);
          }
          if (!trackName) {
            trackName = 'Track ' + (index + 1);
          }
          // Add instrument info if available
          if (track.playbackInfo && track.playbackInfo.primaryChannel) {
            const isPercussion = track.playbackInfo.primaryChannel.isPercussion;
            if (isPercussion) {
              trackName += ' (Drums)';
            }
          }
          option.textContent = trackName;
          select.appendChild(option);
        });

        select.disabled = false;

        // Set up change handler if not already done
        if (!select.dataset.handlerAttached) {
          select.addEventListener('change', () => {
            const trackIndex = parseInt(select.value, 10);
            if (!isNaN(trackIndex) && api && api.tracks) {
              const score = api.score;
              if (score && score.tracks && score.tracks[trackIndex]) {
                // Use renderTracks to show only the selected track
                api.renderTracks([score.tracks[trackIndex]]);
                console.log('Switched to track:', trackIndex, score.tracks[trackIndex].name);
              }
            }
          });
          select.dataset.handlerAttached = 'true';
        }

        console.log('Track selector populated with', score.tracks.length, 'tracks');
      }

      function normalizeAlphaScore(data) {
        try {
          if (!data || typeof data !== 'object') return data;
          // Ensure stylesheet and masterBars exist
          data.stylesheet = data.stylesheet || {};
          if (!Array.isArray(data.masterBars)) data.masterBars = [];
          // Attach backrefs and fill masterBars by inspecting first track/staff
          if (Array.isArray(data.tracks)) {
            for (const t of data.tracks) {
              if (!t || typeof t !== 'object') continue;
              t.score = t.score || data;
              if (!t.playbackInfo) {
                t.playbackInfo = {
                  primaryChannel: { program: 25, volume: 1.0, balance: 0.0, isPercussion: false },
                  secondaryChannel: { program: 25, volume: 1.0, balance: 0.0, isPercussion: false },
                };
              }
              if (!Array.isArray(t.staves)) continue;
              for (const s of t.staves) {
                if (!s || typeof s !== 'object') continue;
                s.track = s.track || t;
                if (!Array.isArray(s.bars)) continue;
                for (let i = 0; i < s.bars.length; i++) {
                  const b = s.bars[i];
                  if (!b || typeof b !== 'object') continue;
                  b.staff = b.staff || s;
                  const ts = b.timeSignature || data.timeSignature || [4, 4];
                  // Ensure masterBars[i]
                  if (!data.masterBars[i]) data.masterBars[i] = {};
                  const mb = data.masterBars[i];
                  if (!Array.isArray(mb.timeSignature)) mb.timeSignature = [ts[0], ts[1]];
                  if (!mb.repeatGroup) mb.repeatGroup = { opening: false, closing: false, repeatCount: 0 };
                  if (!Array.isArray(b.voices)) continue;
                  for (const v of b.voices) {
                    if (!v || typeof v !== 'object') continue;
                    v.bar = v.bar || b;
                    if (!Array.isArray(v.beats)) continue;
                    for (const be of v.beats) {
                      if (!be || typeof be !== 'object') continue;
                      be.voice = be.voice || v;
                      if (!Array.isArray(be.notes)) continue;
                      for (const n of be.notes) {
                        if (!n || typeof n !== 'object') continue;
                        n.beat = n.beat || be;
                      }
                    }
                  }
                }
              }
            }
          }
        } catch (e) {
          // ignore normalization errors; alphaTab will show a render error
        }
        return data;
      }

      function toAlphaTex(data) {
        try {
          if (!data || !Array.isArray(data.tracks)) return null;
          const t = data.tracks[0];
          if (!t || !Array.isArray(t.staves)) return null;
          const s = t.staves[0];
          if (!s || !Array.isArray(s.bars)) return null;
          const parts = [];
          for (let bi = 0; bi < s.bars.length; bi++) {
            const b = s.bars[bi];
            const voices = Array.isArray(b.voices) ? b.voices : [];
            const v = voices[0] || { beats: [] };
            const beats = Array.isArray(v.beats) ? v.beats : [];
            const beatTokens = [];
            for (const be of beats) {
              const dur = Array.isArray(be.duration) ? be.duration : [1, 4];
              const den = dur[1] || 4;
              if (be.rest) {
                beatTokens.push('r.' + den);
                continue;
              }
              const notes = Array.isArray(be.notes) ? be.notes.filter((n) => !n.rest) : [];
              if (notes.length === 0) {
                beatTokens.push('r.' + den);
                continue;
              }
              if (notes.length === 1) {
                const n = notes[0];
                const tie = !!n.tie;
                const fret = tie ? '-' : typeof n.fret === 'number' ? n.fret : 0;
                const string = typeof n.string === 'number' ? n.string : 1;
                const hasH = !!(n.hammerOn || n.pullOff);
                const base = fret + '.' + string;
                const withEff = hasH ? base + '{h}' : base;
                beatTokens.push(withEff + '.' + den);
              } else {
                // Sort by string to keep consistent order for chord ties
                const chordNotes = notes.slice().sort((a, b) => {
                  const sa = typeof a.string === 'number' ? a.string : 1;
                  const sb = typeof b.string === 'number' ? b.string : 1;
                  return sa - sb;
                });
                const chord = chordNotes
                  .map((n) => {
                    const tie = !!n.tie;
                    const fret = tie ? '-' : typeof n.fret === 'number' ? n.fret : 0;
                    const string = typeof n.string === 'number' ? n.string : 1;
                    const hasH = !!(n.hammerOn || n.pullOff);
                    return hasH ? fret + '.' + string + '{h}' : fret + '.' + string;
                  })
                  .join(' ');
                beatTokens.push('(' + chord + ').' + den);
              }
            }
            parts.push(beatTokens.join(' '));
          }
          const title = data.title || (data.song && data.song.title) || (t && t.name) || 'Guitar';
          const tempo = data.tempo || 120;
          // AlphaTex header: title, tempo, time signature, and staff type
          const ts = data.timeSignature || [4, 4];
          const header = `\\title "${title}" \\tempo ${tempo} \\ts ${ts[0]} ${ts[1]} \\track "Guitar" \\staff{tabs} \\tuning E4 B3 G3 D3 A2 E2 `;
          return header + parts.join(' | ');
        } catch (e) {
          return null;
        }
      }

      function normalizeArcOrientation(svgEl) {
        if (!svgEl) return;
        const getStaffMid = () => {
          try {
            const lines = Array.from(svgEl.querySelectorAll('line')).filter((l) => (l.getAttribute('x1') || '') !== (l.getAttribute('x2') || ''));
            const ys = lines.map((l) => parseFloat(l.getAttribute('y1') || '0')).sort((a, b) => a - b);
            return ys.length >= 2 ? (ys[0] + ys[ys.length - 1]) / 2 : null;
          } catch (e) {
            return null;
          }
        };
        const isArcUp = (path) => {
          const d = path.getAttribute('d') || '';
          // Look for first cubic or quadratic segment
          const m = d.match(/[CQ]\s*([\d.+-eE]+)[,\s]([\d.+-eE]+)\s+([\d.+-eE]+)[,\s]([\d.+-eE]+)\s+([\d.+-eE]+)[,\s]([\d.+-eE]+)/);
          const ms = d.match(/M\s*([\d.+-eE]+)[,\s]([\d.+-eE]+)/);
          if (m && ms) {
            const y1 = parseFloat(m[2]);
            const y2 = parseFloat(m[4]);
            const ye = parseFloat(m[6]);
            const ys = parseFloat(ms[2]);
            const ctrlAvg = (y1 + y2) / 2;
            const endAvg = (ys + ye) / 2;
            // SVG y goes downwards: smaller y = above. If control avg is smaller => arc bulges up
            return ctrlAvg < endAvg;
          }
          // Fallback for non-Q/C paths (e.g., elliptical A paths): compare bbox center to staff mid
          try {
            const bb = path.getBBox();
            const cy = bb.y + bb.height / 2;
            const mid = getStaffMid();
            if (mid == null) return null;
            return cy < mid;
          } catch (e) {
            return null;
          }
        };
        const isArcCandidatePath = (path) => {
          const d = path.getAttribute('d') || '';
          // Must be a curve and typically no fill
          if (!/[CQ]/.test(d)) return false;
          const fill = (path.getAttribute('fill') || '').toLowerCase();
          if (fill && fill !== 'none') return false;
          try {
            const bb = path.getBBox();
            const thin = bb.height <= 40; // relaxed
            const wide = bb.width >= 8;
            return thin && wide;
          } catch (e) {
            return false;
          }
        };
        const isArcCandidateUse = (useEl) => {
          try {
            const bb = useEl.getBBox();
            const thin = bb.height <= 40;
            const wide = bb.width >= 8;
            // <use> clones of glyphs usually have no fill attribute set
            return thin && wide;
          } catch (e) {
            return false;
          }
        };
        const hasHpLabelNear = (path) => {
          try {
            const pb = path.getBBox();
            const cx = pb.x + pb.width / 2;
            const cy = pb.y + pb.height / 2;
            const texts = svgEl.querySelectorAll('text');
            for (const t of texts) {
              const txt = (t.textContent || '').trim().toUpperCase();
              if (txt !== 'H' && txt !== 'P') continue;
              const tb = t.getBBox();
              const tx = tb.x + tb.width / 2;
              const ty = tb.y + tb.height / 2;
              const dx = Math.abs(tx - cx);
              const dy = Math.abs(ty - cy);
              if (dx < 40 && dy < 30) return true;
            }
          } catch (e) {
            /* ignore */
          }
          return false;
        };
        const flipVert = (el) => {
          const bb = el.getBBox();
          const cx = bb.x + bb.width / 2;
          const cy = bb.y + bb.height / 2;
          const prev = el.getAttribute('transform') || '';
          if (prev.includes('scale(1 -1)')) return; // already flipped
          const t = ` translate(${cx} ${cy}) scale(1 -1) translate(${-cx} ${-cy})`;
          el.setAttribute('transform', prev + t);
          el.setAttribute('data-flipped', '1');
        };
        // Find likely tie/slur shapes and normalize direction
        // 1) Paths with curves
        svgEl.querySelectorAll('path').forEach((p) => {
          if (!isArcCandidatePath(p)) return;
          const up = isArcUp(p);
          if (up === null) return;
          const clsSelf = (p.getAttribute('class') || '').toLowerCase();
          const parent = p.parentNode && p.parentNode.tagName === 'g' ? p.parentNode : null;
          const clsParent = parent ? (parent.getAttribute('class') || '').toLowerCase() : '';
          const combined = clsSelf + ' ' + clsParent;
          const isTieClass = combined.includes('tie');
          const isSlurClass = combined.includes('slur') || combined.includes('hammer') || combined.includes('pull');
          const isHp = isSlurClass || hasHpLabelNear(p);
          const target = parent && (isTieClass || isSlurClass) ? parent : p;
          if (isHp) {
            if (!up) flipVert(target);
          } else {
            if (up) flipVert(target);
          }
        });
        // 2) <use> glyph clones (some builds draw ties/slurs as glyphs)
        svgEl.querySelectorAll('use').forEach((u) => {
          if (!isArcCandidateUse(u)) return;
          // We cannot parse 'd' from <use>, approximate using bbox: if center Y above tab middle, treat as up.
          let up = null;
          try {
            const bb = u.getBBox();
            const cy = bb.y + bb.height / 2;
            // Estimate staff middle from the median of horizontal lines
            const lines = Array.from(svgEl.querySelectorAll('line')).filter((l) => (l.getAttribute('x1') || '') !== (l.getAttribute('x2') || ''));
            const ys = lines.map((l) => parseFloat(l.getAttribute('y1') || '0')).sort((a, b) => a - b);
            const mid = ys.length >= 2 ? (ys[0] + ys[ys.length - 1]) / 2 : cy;
            up = cy < mid;
          } catch (e) {
            up = null;
          }
          if (up === null) return;
          const clsSelf = (u.getAttribute('class') || '').toLowerCase();
          const parent = u.parentNode && u.parentNode.tagName === 'g' ? u.parentNode : null;
          const clsParent = parent ? (parent.getAttribute('class') || '').toLowerCase() : '';
          const combined = clsSelf + ' ' + clsParent;
          const isTieClass = combined.includes('tie');
          const isSlurClass = combined.includes('slur') || combined.includes('hammer') || combined.includes('pull');
          const isHp = isSlurClass || hasHpLabelNear(u);
          const target = parent && (isTieClass || isSlurClass) ? parent : u;
          if (isHp) {
            if (!up) flipVert(target);
          } else {
            if (up) flipVert(target);
          }
        });
      }

      // old chat gpt method (probably dont need)(keep just in case)(for now)

      function applyDarkTheme(svgEl) {
        if (!svgEl) return;
        try {
          // Ensure currentColor-based paints resolve to white
          svgEl.style.color = '#ffffff';
          // Inject a style override inside the SVG to catch any missed elements
          const styleNode = document.createElementNS('http://www.w3.org/2000/svg', 'style');
          styleNode.setAttribute('id', 'at-dark-style');
          styleNode.textContent = `
            path, line, polyline, polygon, rect, circle, ellipse, use { stroke: #ffffff !important; }
            text, tspan { fill: #ffffff !important; }
            *[fill='none'] { fill: none !important; }
          `;
          if (!svgEl.querySelector('#at-dark-style')) {
            svgEl.insertBefore(styleNode, svgEl.firstChild);
          }
        } catch (e) {
          /* ignore */
        }
      }

      // old chat gpt method (probably dont need)(keep just in case)(for now)

      function setupPlayerBindings(apiInstance) {
        if (!apiInstance) return;

        const playPauseBtn = document.getElementById('at-play-pause');
        const restartBtn = document.getElementById('at-restart');
        const tempoSlider = document.getElementById('at-tempo');
        const tempoLabel = document.getElementById('at-tempo-label');
        const statusLabel = document.getElementById('at-status');
        if (!playPauseBtn || !restartBtn || !tempoSlider || !tempoLabel) {
          return;
        }

        let isScrubbing = false;

        const PlayerState = window.alphaTab && window.alphaTab.synth && window.alphaTab.synth.PlayerState ? window.alphaTab.synth.PlayerState : null;

        function updateTempoLabel(value) {
          const v = typeof value === 'number' ? value : parseFloat(tempoSlider.value || '1');
          tempoLabel.textContent = v.toFixed(1) + 'x';
        }

        function updateProgressState() {
          if (!playerDurationMs || isScrubbing) return;
        }

        // Initial state
        playPauseBtn.disabled = false;
        restartBtn.disabled = false;
        updateTempoLabel(parseFloat(tempoSlider.value || '1'));
        if (statusLabel) statusLabel.textContent = '';

        playPauseBtn.addEventListener('click', () => {
          try {
            // Check Web Audio API support
            const hasWebAudio = !!(window.AudioContext || window.webkitAudioContext);
            const state = apiInstance.playerState;
            const score = apiInstance.score;
            console.log('Play clicked - hasWebAudio:', hasWebAudio, 'playerState:', state, 'hasScore:', !!score);

            if (!hasWebAudio) {
              if (statusLabel) statusLabel.textContent = 'Error: Web Audio not supported in this WebView';
              return;
            }

            if (statusLabel) statusLabel.textContent = 'Playing...';

            // Try to play
            if (apiInstance.playPause) {
              apiInstance.playPause();
            } else if (apiInstance.play) {
              apiInstance.play();
            }
          } catch (e) {
            console.error('Play/pause error:', e);
            if (statusLabel) statusLabel.textContent = 'Error: ' + (e.message || e);
          }
        });

        restartBtn.addEventListener('click', () => {
          try {
            if (apiInstance.stop) apiInstance.stop();
            if (apiInstance.seek) apiInstance.seek(0);
            playerPositionMs = 0;
          } catch (e) {
            console.error('Restart error:', e);
          }
        });

        tempoSlider.addEventListener('input', () => {
          const v = parseFloat(tempoSlider.value || '1');
          updateTempoLabel(v);
          try {
            apiInstance.playbackSpeed = v;
          } catch (e) {
            /* ignore */
          }
        });

        if (apiInstance.playerStateChanged && apiInstance.playerStateChanged.on) {
          apiInstance.playerStateChanged.on((e) => {
            let playing = false;
            if (PlayerState && e && typeof e.state !== 'undefined') {
              playing = e.state === PlayerState.Playing;
            } else {
              const state = e && e.state ? String(e.state).toLowerCase() : '';
              playing = state === 'playing';
            }
            playPauseBtn.textContent = playing ? 'Pause' : 'Play';
            if (statusLabel) {
              statusLabel.textContent = playing ? 'Player state: Playing' : 'Player state: Stopped';
            }
          });
        }

        if (apiInstance.playerPositionChanged && apiInstance.playerPositionChanged.on) {
          apiInstance.playerPositionChanged.on((e) => {
            if (!e) return;
            if (typeof e.endTime === 'number') {
              playerDurationMs = e.endTime;
            }
            if (typeof e.currentTime === 'number') {
              playerPositionMs = e.currentTime;
              updateProgressState();
            }
          });
        }
      }

      function renderScore(alphaTabScoreJson) {
        const el = document.getElementById('at');
        const api = ensureApi();
        if (!api) return;
        let data = {};
        try {
          data = JSON.parse(alphaTabScoreJson || '{}');
        } catch (e) {
          el.innerHTML = '<div style="padding:12px">Invalid score JSON.</div>';
          return;
        }
        try {
          // Prefer using alphaTab's ModelSerializer if available
          let scoreObj = null;
          try {
            const at = window.alphaTab || {};
            const ser =
              at.model && at.model.serialization && at.model.serialization.ModelSerializer
                ? at.model.serialization.ModelSerializer
                : at.serialization && at.serialization.ModelSerializer
                ? at.serialization.ModelSerializer
                : null;
            if (ser && typeof ser.deserializeScore === 'function') {
              scoreObj = ser.deserializeScore(data);
            }
          } catch (e) {
            scoreObj = null;
          }

          // Reset player ready state when loading new score
          playerReady = false;
          const statusLabel = document.getElementById('at-status');
          if (statusLabel) statusLabel.textContent = 'Loading score...';

          let usedTex = false;
          if (!scoreObj) {
            // Try AlphaTex fallback first for robust rendering and playback
            const tex = toAlphaTex(data);
            console.log('Generated AlphaTex:', tex ? tex.substring(0, 200) + '...' : 'null');
            if (tex && typeof api.tex === 'function') {
              console.log('Using api.tex() for rendering');
              api.tex(tex);
              usedTex = true;
            } else {
              console.log('AlphaTex not available, normalizing score data');
              data = normalizeAlphaScore(data);
            }
          } else {
            console.log('Using deserialized score object');
          }

          if (!usedTex) {
            const payload = scoreObj || data;
            // Use api.load() which properly initializes both rendering AND player/synthesizer
            console.log('Loading score via api.load/renderScore/loadScore');
            if (api.load) {
              api.load(payload);
            } else if (api.renderScore) {
              api.renderScore(payload);
            } else if (api.loadScore) {
              api.loadScore(payload);
            }
          }
          // Don't call render() separately - load/tex already triggers rendering
          console.log('Score loading initiated, waiting for playerReady event...');
          setTimeout(() => {
            const svgEl = el.querySelector('svg');
            normalizeArcOrientation(svgEl);
            // applyDarkTheme(svgEl);
            const svg = svgEl ? svgEl.outerHTML : '';
            if (window.javaConnector && window.javaConnector.onSvgReady) {
              try {
                window.javaConnector.onSvgReady(svg);
              } catch (e) {
                /* ignored */
              }
            }
          }, 100);
        } catch (e) {
          el.innerHTML = '<div style="padding:12px">Render error: ' + (e && e.message ? e.message : e) + '</div>';
        }
      }

      function exportSvg() {
        const svgEl = document.getElementById('at').querySelector('svg');
        return svgEl ? svgEl.outerHTML : '';
      }

      window.renderScore = renderScore;
      window.exportSvg = exportSvg;
      window.alphaTabPlayer = {
        play() {
          const instance = ensureApi();
          if (instance && instance.play) instance.play();
        },
        pause() {
          const instance = ensureApi();
          if (instance && instance.pause) instance.pause();
        },
        stop() {
          const instance = ensureApi();
          if (instance && instance.stop) instance.stop();
        },
        restart() {
          const instance = ensureApi();
          if (!instance) return;
          try {
            if (instance.stop) instance.stop();
            if (instance.seek) instance.seek(0);
          } catch (e) {
            /* ignore */
          }
        },
        setTempo(multiplier) {
          const instance = ensureApi();
          if (!instance) return;
          try {
            instance.playbackSpeed = multiplier;
          } catch (e) {
            /* ignore */
          }
        },
        getPositionMs() {
          return playerPositionMs || 0;
        },
        getDurationMs() {
          return playerDurationMs || 0;
        },
      };

      window.loadGpFromJava = function (base64) {
        try {
          const api = ensureApi();
          if (!api || !api.load || !base64) return;
          const binary = window.atob(base64);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          api.load(bytes.buffer);
        } catch (e) {
          /* ignore load errors; Java side shows status */
        }
      };
    </script>
  </body>
</html>
