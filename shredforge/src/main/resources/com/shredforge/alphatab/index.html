<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AlphaTab Host</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #222222;
        color: #ffffff;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        font-size: 13px;
      }
      #root {
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
      }
      #at-controls {
        box-sizing: border-box;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        background: #1a1a1a;
        border-bottom: 1px solid #333333;
      }
      #at-controls button,
      #at-controls input[type='range'] {
        cursor: pointer;
      }
      .at-btn {
        padding: 4px 10px;
        border-radius: 4px;
        border: 1px solid #444444;
        background: #2d2d2d;
        color: #ffffff;
      }
      .at-btn:hover {
        background: #3a3a3a;
      }
      .at-btn:disabled {
        opacity: 0.5;
        cursor: default;
      }
      #at-playback-progress {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 4px;
        border-radius: 999px;
        background: #333333;
      }
      #at-playback-progress::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #4a90d9;
        margin-top: -3px;
      }
      #at-playback-progress::-moz-range-thumb {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #4a90d9;
      }
      #at-tempo {
        width: 100px;
      }
      #at-track-select {
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #444444;
        background: #2d2d2d;
        color: #ffffff;
        font-size: 13px;
        max-width: 200px;
      }
      #at-track-select:disabled {
        opacity: 0.5;
      }
      #at-tempo-label {
        min-width: 40px;
        text-align: right;
      }
      #at-container {
        flex: 1 1 auto;
        min-height: 0;
      }
      #at {
        width: 100%;
        height: 100%;
        overflow: auto;
      }
      /* Songsterr-style player visuals - no bar highlight, just cursor */
      #at svg .at-selection {
        fill: transparent;
      }
      /* Hide the bar background highlight completely */
      #at .at-highlight {
        display: none !important;
      }
      #at .at-cursor-bar {
        display: none !important;
      }
      /* Thin beat cursor line like Songsterr */
      #at .at-cursor-beat {
        background: #4a90d9;
        width: 2px;
        opacity: 0.9;
      }
      /* Notes should be white/bright */
      #at svg .at-highlight {
        fill: transparent !important;
        stroke: transparent !important;
      }
      /* Force all text to white for dark theme */
      #at svg text {
        fill: #ffffff !important;
      }
      /* Make fret numbers pop with slightly larger weight */
      #at svg text.at-fret-number,
      #at svg .at-tab-note text {
        fill: #ffffff !important;
        font-weight: 500;
      }
      .hidden {
        display: none;
      }
      /* Practice feedback overlay */
      #practice-feedback {
        position: fixed;
        top: 60px;
        right: 10px;
        width: 180px;
        background: rgba(0, 0, 0, 0.85);
        border-radius: 8px;
        padding: 10px;
        z-index: 1000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        display: none;
      }
      #practice-feedback.active {
        display: block;
      }
      #practice-feedback h4 {
        margin: 0 0 8px 0;
        font-size: 12px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .feedback-item {
        padding: 4px 8px;
        margin: 3px 0;
        border-radius: 4px;
        font-size: 13px;
        font-weight: 500;
        animation: fadeIn 0.2s ease-out;
      }
      .feedback-item.hit {
        background: rgba(34, 197, 94, 0.3);
        color: #22c55e;
        border-left: 3px solid #22c55e;
      }
      .feedback-item.missed {
        background: rgba(239, 68, 68, 0.3);
        color: #ef4444;
        border-left: 3px solid #ef4444;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateX(10px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      /* Flash effect on cursor for hits/misses */
      .cursor-flash-hit {
        box-shadow: 0 0 20px 5px rgba(34, 197, 94, 0.8) !important;
        background: #22c55e !important;
      }
      .cursor-flash-miss {
        box-shadow: 0 0 20px 5px rgba(239, 68, 68, 0.8) !important;
        background: #ef4444 !important;
      }
    </style>
    <script>
      (function () {
        function load(src, onload) {
          var s = document.createElement('script');
          s.src = src;
          s.onload = onload;
          s.onerror = function () {
            onload(true);
          };
          document.head.appendChild(s);
        }
        // Try local first as required; fall back to CDN if missing
        load('alphatab.js', function (err) {
          if (err || !window.alphaTab) {
            load('https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.6.0/dist/alphaTab.js', function () {});
          }
        });
      })();
    </script>
    <script src="alphatab.wasm"></script>
  </head>
  <body>
    <div id="root">
      <div id="at-controls">
        <button id="at-play-pause" class="at-btn" disabled>Play</button>
        <button id="at-restart" class="at-btn" disabled>Restart</button>
        <select id="at-track-select" disabled>
          <option value="">No track loaded</option>
        </select>
        <div style="flex: 1 1 auto"></div>
        <span id="at-status" style="font-size: 11px; opacity: 0.8"></span>
        <label for="at-tempo">Tempo</label>
        <input id="at-tempo" type="range" min="0.5" max="1.5" step="0.05" value="1.0" />
        <span id="at-tempo-label">1.0x</span>
      </div>
      <div id="at-container">
        <div id="at"></div>
      </div>
      <!-- Practice feedback overlay -->
      <div id="practice-feedback">
        <h4>Live Feedback</h4>
        <div id="feedback-list"></div>
      </div>
    </div>
    <script>
      let api = null;
      let playerDurationMs = 0;
      let playerPositionMs = 0;
      let playerReady = false;

      function ensureApi() {
        if (api) return api;
        const el = document.getElementById('at');
        if (!window.alphaTab || !window.alphaTab.AlphaTabApi) {
          el.innerHTML = '<div style="padding:12px">AlphaTab library not loaded.</div>';
          return null;
        }
        // Use soundfont URL from Java (injected as window.javaSoundFontUrl), or fall back to CDN
        const sfUrl = window.javaSoundFontUrl || 'https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.6.0/dist/soundfont/sonivox.sf2';
        const sfLen = sfUrl ? sfUrl.length : 0;
        console.log('Creating AlphaTab API with soundfont length:', sfLen, 'isDataUrl:', sfUrl.startsWith('data:'));
        api = new window.alphaTab.AlphaTabApi(el, {
          engine: 'svg',
          player: {
            enablePlayer: true,
            soundFont: sfUrl,
            scrollElement: document.getElementById('at-container'),
            enableCursor: true,
            enableUserInteraction: true,
            // Songsterr-style: beat cursor only, no bar highlighting
            enableElementHighlighting: false,
          },
          // Songsterr-style dark theme colors
          display: {
            resources: {
              staffLineColor: '#555555',
              barSeparatorColor: '#444444',
              mainGlyphColor: '#ffffff',
              secondaryGlyphColor: '#aaaaaa',
              scoreInfoColor: '#888888',
              barNumberColor: '#666666',
            },
          },
          // Show rhythm
          notation: {
            rhythmMode: 'ShowWithBars',
            extendLineEffectsToBeatEnd: true,
          },
        });

        // Hide standard notation, show only tab - must be done on scoreLoaded
        if (api.scoreLoaded && api.scoreLoaded.on) {
          api.scoreLoaded.on((score) => {
            if (score && score.tracks) {
              for (const track of score.tracks) {
                if (track.staves) {
                  for (const staff of track.staves) {
                    staff.showTablature = true;
                    staff.showStandardNotation = false;
                  }
                }
              }
            }
            // Re-render with the modified settings
            if (api.render) {
              api.render();
            }
          });
        }

        if (api.renderFinished && api.renderFinished.on) {
          api.renderFinished.on(() => {
            const svgEl = el.querySelector('svg');
            normalizeArcOrientation(svgEl);
            const svg = svgEl ? svgEl.outerHTML : '';
            if (window.javaConnector && window.javaConnector.onSvgReady) {
              try {
                window.javaConnector.onSvgReady(svg);
              } catch (e) {
                /* ignored */
              }
            }
          });
        }

        try {
          setupPlayerBindings(api);
        } catch (e) {
          /* ignore player binding errors */
        }

        // Listen for player ready event
        if (api.playerReady && api.playerReady.on) {
          api.playerReady.on(() => {
            playerReady = true;
            const statusLabel = document.getElementById('at-status');
            if (statusLabel) statusLabel.textContent = 'Player ready';
            console.log('AlphaTab player ready');
          });
        }

        // Listen for soundfont load progress events
        if (api.soundFontLoad && api.soundFontLoad.on) {
          api.soundFontLoad.on((e) => {
            const pct = e && e.total ? Math.floor((e.loaded / e.total) * 100) : 0;
            console.log('SoundFont loading:', pct + '%', e);
            const statusLabel = document.getElementById('at-status');
            if (statusLabel && !playerReady) {
              statusLabel.textContent = 'Loading soundfont: ' + pct + '%';
            }
          });
        }

        // Listen for errors
        if (api.error && api.error.on) {
          api.error.on((e) => {
            console.error('AlphaTab error:', e);
            const statusLabel = document.getElementById('at-status');
            if (statusLabel) {
              statusLabel.textContent = 'Error: ' + (e && e.message ? e.message : e);
            }
          });
        }

        // Listen for score loaded event
        if (api.scoreLoaded && api.scoreLoaded.on) {
          api.scoreLoaded.on((score) => {
            console.log('Score loaded:', score ? score.title : 'unknown');
            populateTrackSelector(score);
          });
        }

        // Listen for MIDI load events (important for playback)
        if (api.midiLoad && api.midiLoad.on) {
          api.midiLoad.on((e) => {
            console.log('MIDI loading:', e);
          });
        }

        if (api.midiLoaded && api.midiLoaded.on) {
          api.midiLoaded.on(() => {
            console.log('MIDI loaded - playback should work now');
          });
        }

        return api;
      }

      /**
       * Populates the track selector dropdown with tracks from the loaded score.
       */
      function populateTrackSelector(score) {
        const select = document.getElementById('at-track-select');
        if (!select) return;

        // Clear existing options
        select.innerHTML = '';

        if (!score || !score.tracks || score.tracks.length === 0) {
          select.innerHTML = '<option value="">No tracks available</option>';
          select.disabled = true;
          return;
        }

        // Add an option for each track
        score.tracks.forEach((track, index) => {
          const option = document.createElement('option');
          option.value = index;
          // Build track name: use track name, or instrument name, or fallback
          let trackName = track.name || '';
          if (!trackName && track.playbackInfo) {
            // Try to get instrument name from MIDI program
            trackName = 'Track ' + (index + 1);
          }
          if (!trackName) {
            trackName = 'Track ' + (index + 1);
          }
          // Add instrument info if available
          if (track.playbackInfo && track.playbackInfo.primaryChannel) {
            const isPercussion = track.playbackInfo.primaryChannel.isPercussion;
            if (isPercussion) {
              trackName += ' (Drums)';
            }
          }
          option.textContent = trackName;
          select.appendChild(option);
        });

        select.disabled = false;

        // Set up change handler if not already done
        if (!select.dataset.handlerAttached) {
          select.addEventListener('change', () => {
            const trackIndex = parseInt(select.value, 10);
            if (!isNaN(trackIndex) && api && api.tracks) {
              const score = api.score;
              if (score && score.tracks && score.tracks[trackIndex]) {
                // Use renderTracks to show only the selected track
                api.renderTracks([score.tracks[trackIndex]]);
                console.log('Switched to track:', trackIndex, score.tracks[trackIndex].name);

                // Notify Java about track change so it can re-extract notes if in practice mode
                if (window.cefQuery) {
                  window.cefQuery({
                    request: 'trackChanged:' + trackIndex,
                    onSuccess: function (response) {
                      console.log('Track change notified to Java');
                    },
                    onFailure: function (errorCode, errorMessage) {
                      // Ignore failures - Java may not be listening
                    },
                  });
                }
              }
            }
          });
          select.dataset.handlerAttached = 'true';
        }

        console.log('Track selector populated with', score.tracks.length, 'tracks');
      }

      function normalizeAlphaScore(data) {
        try {
          if (!data || typeof data !== 'object') return data;
          // Ensure stylesheet and masterBars exist
          data.stylesheet = data.stylesheet || {};
          if (!Array.isArray(data.masterBars)) data.masterBars = [];
          // Attach backrefs and fill masterBars by inspecting first track/staff
          if (Array.isArray(data.tracks)) {
            for (const t of data.tracks) {
              if (!t || typeof t !== 'object') continue;
              t.score = t.score || data;
              if (!t.playbackInfo) {
                t.playbackInfo = {
                  primaryChannel: { program: 25, volume: 1.0, balance: 0.0, isPercussion: false },
                  secondaryChannel: { program: 25, volume: 1.0, balance: 0.0, isPercussion: false },
                };
              }
              if (!Array.isArray(t.staves)) continue;
              for (const s of t.staves) {
                if (!s || typeof s !== 'object') continue;
                s.track = s.track || t;
                if (!Array.isArray(s.bars)) continue;
                for (let i = 0; i < s.bars.length; i++) {
                  const b = s.bars[i];
                  if (!b || typeof b !== 'object') continue;
                  b.staff = b.staff || s;
                  const ts = b.timeSignature || data.timeSignature || [4, 4];
                  // Ensure masterBars[i]
                  if (!data.masterBars[i]) data.masterBars[i] = {};
                  const mb = data.masterBars[i];
                  if (!Array.isArray(mb.timeSignature)) mb.timeSignature = [ts[0], ts[1]];
                  if (!mb.repeatGroup) mb.repeatGroup = { opening: false, closing: false, repeatCount: 0 };
                  if (!Array.isArray(b.voices)) continue;
                  for (const v of b.voices) {
                    if (!v || typeof v !== 'object') continue;
                    v.bar = v.bar || b;
                    if (!Array.isArray(v.beats)) continue;
                    for (const be of v.beats) {
                      if (!be || typeof be !== 'object') continue;
                      be.voice = be.voice || v;
                      if (!Array.isArray(be.notes)) continue;
                      for (const n of be.notes) {
                        if (!n || typeof n !== 'object') continue;
                        n.beat = n.beat || be;
                      }
                    }
                  }
                }
              }
            }
          }
        } catch (e) {
          // ignore normalization errors; alphaTab will show a render error
        }
        return data;
      }

      function toAlphaTex(data) {
        try {
          if (!data || !Array.isArray(data.tracks)) return null;
          const t = data.tracks[0];
          if (!t || !Array.isArray(t.staves)) return null;
          const s = t.staves[0];
          if (!s || !Array.isArray(s.bars)) return null;
          const parts = [];
          for (let bi = 0; bi < s.bars.length; bi++) {
            const b = s.bars[bi];
            const voices = Array.isArray(b.voices) ? b.voices : [];
            const v = voices[0] || { beats: [] };
            const beats = Array.isArray(v.beats) ? v.beats : [];
            const beatTokens = [];
            for (const be of beats) {
              const dur = Array.isArray(be.duration) ? be.duration : [1, 4];
              const den = dur[1] || 4;
              if (be.rest) {
                beatTokens.push('r.' + den);
                continue;
              }
              const notes = Array.isArray(be.notes) ? be.notes.filter((n) => !n.rest) : [];
              if (notes.length === 0) {
                beatTokens.push('r.' + den);
                continue;
              }
              if (notes.length === 1) {
                const n = notes[0];
                const tie = !!n.tie;
                const fret = tie ? '-' : typeof n.fret === 'number' ? n.fret : 0;
                const string = typeof n.string === 'number' ? n.string : 1;
                const hasH = !!(n.hammerOn || n.pullOff);
                const base = fret + '.' + string;
                const withEff = hasH ? base + '{h}' : base;
                beatTokens.push(withEff + '.' + den);
              } else {
                // Sort by string to keep consistent order for chord ties
                const chordNotes = notes.slice().sort((a, b) => {
                  const sa = typeof a.string === 'number' ? a.string : 1;
                  const sb = typeof b.string === 'number' ? b.string : 1;
                  return sa - sb;
                });
                const chord = chordNotes
                  .map((n) => {
                    const tie = !!n.tie;
                    const fret = tie ? '-' : typeof n.fret === 'number' ? n.fret : 0;
                    const string = typeof n.string === 'number' ? n.string : 1;
                    const hasH = !!(n.hammerOn || n.pullOff);
                    return hasH ? fret + '.' + string + '{h}' : fret + '.' + string;
                  })
                  .join(' ');
                beatTokens.push('(' + chord + ').' + den);
              }
            }
            parts.push(beatTokens.join(' '));
          }
          const title = data.title || (data.song && data.song.title) || (t && t.name) || 'Guitar';
          const tempo = data.tempo || 120;
          // AlphaTex header: title, tempo, time signature, and staff type
          const ts = data.timeSignature || [4, 4];
          const header = `\\title "${title}" \\tempo ${tempo} \\ts ${ts[0]} ${ts[1]} \\track "Guitar" \\staff{tabs} \\tuning E4 B3 G3 D3 A2 E2 `;
          return header + parts.join(' | ');
        } catch (e) {
          return null;
        }
      }

      function normalizeArcOrientation(svgEl) {
        if (!svgEl) return;
        const getStaffMid = () => {
          try {
            const lines = Array.from(svgEl.querySelectorAll('line')).filter((l) => (l.getAttribute('x1') || '') !== (l.getAttribute('x2') || ''));
            const ys = lines.map((l) => parseFloat(l.getAttribute('y1') || '0')).sort((a, b) => a - b);
            return ys.length >= 2 ? (ys[0] + ys[ys.length - 1]) / 2 : null;
          } catch (e) {
            return null;
          }
        };
        const isArcUp = (path) => {
          const d = path.getAttribute('d') || '';
          // Look for first cubic or quadratic segment
          const m = d.match(/[CQ]\s*([\d.+-eE]+)[,\s]([\d.+-eE]+)\s+([\d.+-eE]+)[,\s]([\d.+-eE]+)\s+([\d.+-eE]+)[,\s]([\d.+-eE]+)/);
          const ms = d.match(/M\s*([\d.+-eE]+)[,\s]([\d.+-eE]+)/);
          if (m && ms) {
            const y1 = parseFloat(m[2]);
            const y2 = parseFloat(m[4]);
            const ye = parseFloat(m[6]);
            const ys = parseFloat(ms[2]);
            const ctrlAvg = (y1 + y2) / 2;
            const endAvg = (ys + ye) / 2;
            // SVG y goes downwards: smaller y = above. If control avg is smaller => arc bulges up
            return ctrlAvg < endAvg;
          }
          // Fallback for non-Q/C paths (e.g., elliptical A paths): compare bbox center to staff mid
          try {
            const bb = path.getBBox();
            const cy = bb.y + bb.height / 2;
            const mid = getStaffMid();
            if (mid == null) return null;
            return cy < mid;
          } catch (e) {
            return null;
          }
        };
        const isArcCandidatePath = (path) => {
          const d = path.getAttribute('d') || '';
          // Must be a curve and typically no fill
          if (!/[CQ]/.test(d)) return false;
          const fill = (path.getAttribute('fill') || '').toLowerCase();
          if (fill && fill !== 'none') return false;
          try {
            const bb = path.getBBox();
            const thin = bb.height <= 40; // relaxed
            const wide = bb.width >= 8;
            return thin && wide;
          } catch (e) {
            return false;
          }
        };
        const isArcCandidateUse = (useEl) => {
          try {
            const bb = useEl.getBBox();
            const thin = bb.height <= 40;
            const wide = bb.width >= 8;
            // <use> clones of glyphs usually have no fill attribute set
            return thin && wide;
          } catch (e) {
            return false;
          }
        };
        const hasHpLabelNear = (path) => {
          try {
            const pb = path.getBBox();
            const cx = pb.x + pb.width / 2;
            const cy = pb.y + pb.height / 2;
            const texts = svgEl.querySelectorAll('text');
            for (const t of texts) {
              const txt = (t.textContent || '').trim().toUpperCase();
              if (txt !== 'H' && txt !== 'P') continue;
              const tb = t.getBBox();
              const tx = tb.x + tb.width / 2;
              const ty = tb.y + tb.height / 2;
              const dx = Math.abs(tx - cx);
              const dy = Math.abs(ty - cy);
              if (dx < 40 && dy < 30) return true;
            }
          } catch (e) {
            /* ignore */
          }
          return false;
        };
        const flipVert = (el) => {
          const bb = el.getBBox();
          const cx = bb.x + bb.width / 2;
          const cy = bb.y + bb.height / 2;
          const prev = el.getAttribute('transform') || '';
          if (prev.includes('scale(1 -1)')) return; // already flipped
          const t = ` translate(${cx} ${cy}) scale(1 -1) translate(${-cx} ${-cy})`;
          el.setAttribute('transform', prev + t);
          el.setAttribute('data-flipped', '1');
        };
        // Find likely tie/slur shapes and normalize direction
        // 1) Paths with curves
        svgEl.querySelectorAll('path').forEach((p) => {
          if (!isArcCandidatePath(p)) return;
          const up = isArcUp(p);
          if (up === null) return;
          const clsSelf = (p.getAttribute('class') || '').toLowerCase();
          const parent = p.parentNode && p.parentNode.tagName === 'g' ? p.parentNode : null;
          const clsParent = parent ? (parent.getAttribute('class') || '').toLowerCase() : '';
          const combined = clsSelf + ' ' + clsParent;
          const isTieClass = combined.includes('tie');
          const isSlurClass = combined.includes('slur') || combined.includes('hammer') || combined.includes('pull');
          const isHp = isSlurClass || hasHpLabelNear(p);
          const target = parent && (isTieClass || isSlurClass) ? parent : p;
          if (isHp) {
            if (!up) flipVert(target);
          } else {
            if (up) flipVert(target);
          }
        });
        // 2) <use> glyph clones (some builds draw ties/slurs as glyphs)
        svgEl.querySelectorAll('use').forEach((u) => {
          if (!isArcCandidateUse(u)) return;
          // We cannot parse 'd' from <use>, approximate using bbox: if center Y above tab middle, treat as up.
          let up = null;
          try {
            const bb = u.getBBox();
            const cy = bb.y + bb.height / 2;
            // Estimate staff middle from the median of horizontal lines
            const lines = Array.from(svgEl.querySelectorAll('line')).filter((l) => (l.getAttribute('x1') || '') !== (l.getAttribute('x2') || ''));
            const ys = lines.map((l) => parseFloat(l.getAttribute('y1') || '0')).sort((a, b) => a - b);
            const mid = ys.length >= 2 ? (ys[0] + ys[ys.length - 1]) / 2 : cy;
            up = cy < mid;
          } catch (e) {
            up = null;
          }
          if (up === null) return;
          const clsSelf = (u.getAttribute('class') || '').toLowerCase();
          const parent = u.parentNode && u.parentNode.tagName === 'g' ? u.parentNode : null;
          const clsParent = parent ? (parent.getAttribute('class') || '').toLowerCase() : '';
          const combined = clsSelf + ' ' + clsParent;
          const isTieClass = combined.includes('tie');
          const isSlurClass = combined.includes('slur') || combined.includes('hammer') || combined.includes('pull');
          const isHp = isSlurClass || hasHpLabelNear(u);
          const target = parent && (isTieClass || isSlurClass) ? parent : u;
          if (isHp) {
            if (!up) flipVert(target);
          } else {
            if (up) flipVert(target);
          }
        });
      }

      // old chat gpt method (probably dont need)(keep just in case)(for now)

      function applyDarkTheme(svgEl) {
        if (!svgEl) return;
        try {
          // Ensure currentColor-based paints resolve to white
          svgEl.style.color = '#ffffff';
          // Inject a style override inside the SVG to catch any missed elements
          const styleNode = document.createElementNS('http://www.w3.org/2000/svg', 'style');
          styleNode.setAttribute('id', 'at-dark-style');
          styleNode.textContent = `
            path, line, polyline, polygon, rect, circle, ellipse, use { stroke: #ffffff !important; }
            text, tspan { fill: #ffffff !important; }
            *[fill='none'] { fill: none !important; }
          `;
          if (!svgEl.querySelector('#at-dark-style')) {
            svgEl.insertBefore(styleNode, svgEl.firstChild);
          }
        } catch (e) {
          /* ignore */
        }
      }

      // old chat gpt method (probably dont need)(keep just in case)(for now)

      function setupPlayerBindings(apiInstance) {
        if (!apiInstance) return;

        const playPauseBtn = document.getElementById('at-play-pause');
        const restartBtn = document.getElementById('at-restart');
        const tempoSlider = document.getElementById('at-tempo');
        const tempoLabel = document.getElementById('at-tempo-label');
        const statusLabel = document.getElementById('at-status');
        if (!playPauseBtn || !restartBtn || !tempoSlider || !tempoLabel) {
          return;
        }

        let isScrubbing = false;

        const PlayerState = window.alphaTab && window.alphaTab.synth && window.alphaTab.synth.PlayerState ? window.alphaTab.synth.PlayerState : null;

        function updateTempoLabel(value) {
          const v = typeof value === 'number' ? value : parseFloat(tempoSlider.value || '1');
          tempoLabel.textContent = v.toFixed(1) + 'x';
        }

        function updateProgressState() {
          if (!playerDurationMs || isScrubbing) return;
        }

        // Initial state
        playPauseBtn.disabled = false;
        restartBtn.disabled = false;
        updateTempoLabel(parseFloat(tempoSlider.value || '1'));
        if (statusLabel) statusLabel.textContent = '';

        playPauseBtn.addEventListener('click', () => {
          try {
            // Check Web Audio API support
            const hasWebAudio = !!(window.AudioContext || window.webkitAudioContext);
            const state = apiInstance.playerState;
            const score = apiInstance.score;
            console.log('Play clicked - hasWebAudio:', hasWebAudio, 'playerState:', state, 'hasScore:', !!score);

            if (!hasWebAudio) {
              if (statusLabel) statusLabel.textContent = 'Error: Web Audio not supported in this WebView';
              return;
            }

            if (statusLabel) statusLabel.textContent = 'Playing...';

            // Try to play
            if (apiInstance.playPause) {
              apiInstance.playPause();
            } else if (apiInstance.play) {
              apiInstance.play();
            }
          } catch (e) {
            console.error('Play/pause error:', e);
            if (statusLabel) statusLabel.textContent = 'Error: ' + (e.message || e);
          }
        });

        restartBtn.addEventListener('click', () => {
          try {
            if (apiInstance.stop) apiInstance.stop();
            if (apiInstance.seek) apiInstance.seek(0);
            playerPositionMs = 0;
          } catch (e) {
            console.error('Restart error:', e);
          }
        });

        tempoSlider.addEventListener('input', () => {
          const v = parseFloat(tempoSlider.value || '1');
          updateTempoLabel(v);
          try {
            apiInstance.playbackSpeed = v;
          } catch (e) {
            /* ignore */
          }
        });

        if (apiInstance.playerStateChanged && apiInstance.playerStateChanged.on) {
          apiInstance.playerStateChanged.on((e) => {
            let playing = false;
            if (PlayerState && e && typeof e.state !== 'undefined') {
              playing = e.state === PlayerState.Playing;
            } else {
              const state = e && e.state ? String(e.state).toLowerCase() : '';
              playing = state === 'playing';
            }
            playPauseBtn.textContent = playing ? 'Pause' : 'Play';
            if (statusLabel) {
              statusLabel.textContent = playing ? 'Player state: Playing' : 'Player state: Stopped';
            }
          });
        }

        if (apiInstance.playerPositionChanged && apiInstance.playerPositionChanged.on) {
          apiInstance.playerPositionChanged.on((e) => {
            if (!e) return;
            if (typeof e.endTime === 'number') {
              playerDurationMs = e.endTime;
            }
            if (typeof e.currentTime === 'number') {
              playerPositionMs = e.currentTime;
              updateProgressState();

              // Send position to Java for practice mode scoring sync
              if (window.cefQuery) {
                window.cefQuery({
                  request: 'playbackPosition:' + playerPositionMs,
                  onSuccess: function (response) {},
                  onFailure: function (errorCode, errorMessage) {},
                });
              }
            }
          });
        }
      }

      function renderScore(alphaTabScoreJson) {
        const el = document.getElementById('at');
        const api = ensureApi();
        if (!api) return;
        let data = {};
        try {
          data = JSON.parse(alphaTabScoreJson || '{}');
        } catch (e) {
          el.innerHTML = '<div style="padding:12px">Invalid score JSON.</div>';
          return;
        }
        try {
          // Prefer using alphaTab's ModelSerializer if available
          let scoreObj = null;
          try {
            const at = window.alphaTab || {};
            const ser =
              at.model && at.model.serialization && at.model.serialization.ModelSerializer
                ? at.model.serialization.ModelSerializer
                : at.serialization && at.serialization.ModelSerializer
                ? at.serialization.ModelSerializer
                : null;
            if (ser && typeof ser.deserializeScore === 'function') {
              scoreObj = ser.deserializeScore(data);
            }
          } catch (e) {
            scoreObj = null;
          }

          // Reset player ready state when loading new score
          playerReady = false;
          const statusLabel = document.getElementById('at-status');
          if (statusLabel) statusLabel.textContent = 'Loading score...';

          let usedTex = false;
          if (!scoreObj) {
            // Try AlphaTex fallback first for robust rendering and playback
            const tex = toAlphaTex(data);
            console.log('Generated AlphaTex:', tex ? tex.substring(0, 200) + '...' : 'null');
            if (tex && typeof api.tex === 'function') {
              console.log('Using api.tex() for rendering');
              api.tex(tex);
              usedTex = true;
            } else {
              console.log('AlphaTex not available, normalizing score data');
              data = normalizeAlphaScore(data);
            }
          } else {
            console.log('Using deserialized score object');
          }

          if (!usedTex) {
            const payload = scoreObj || data;
            // Use api.load() which properly initializes both rendering AND player/synthesizer
            console.log('Loading score via api.load/renderScore/loadScore');
            if (api.load) {
              api.load(payload);
            } else if (api.renderScore) {
              api.renderScore(payload);
            } else if (api.loadScore) {
              api.loadScore(payload);
            }
          }
          // Don't call render() separately - load/tex already triggers rendering
          console.log('Score loading initiated, waiting for playerReady event...');
          setTimeout(() => {
            const svgEl = el.querySelector('svg');
            normalizeArcOrientation(svgEl);
            // applyDarkTheme(svgEl);
            const svg = svgEl ? svgEl.outerHTML : '';
            if (window.javaConnector && window.javaConnector.onSvgReady) {
              try {
                window.javaConnector.onSvgReady(svg);
              } catch (e) {
                /* ignored */
              }
            }
          }, 100);
        } catch (e) {
          el.innerHTML = '<div style="padding:12px">Render error: ' + (e && e.message ? e.message : e) + '</div>';
        }
      }

      function exportSvg() {
        const svgEl = document.getElementById('at').querySelector('svg');
        return svgEl ? svgEl.outerHTML : '';
      }

      window.renderScore = renderScore;
      window.exportSvg = exportSvg;
      window.alphaTabPlayer = {
        play() {
          const instance = ensureApi();
          if (instance && instance.play) instance.play();
        },
        pause() {
          const instance = ensureApi();
          if (instance && instance.pause) instance.pause();
        },
        stop() {
          const instance = ensureApi();
          if (instance && instance.stop) instance.stop();
        },
        restart() {
          const instance = ensureApi();
          if (!instance) return;
          try {
            if (instance.stop) instance.stop();
            if (instance.seek) instance.seek(0);
          } catch (e) {
            /* ignore */
          }
        },
        setTempo(multiplier) {
          const instance = ensureApi();
          if (!instance) return;
          try {
            instance.playbackSpeed = multiplier;
          } catch (e) {
            /* ignore */
          }
        },
        getPositionMs() {
          return playerPositionMs || 0;
        },
        getDurationMs() {
          return playerDurationMs || 0;
        },
      };

      window.loadGpFromJava = function (base64) {
        try {
          const api = ensureApi();
          if (!api || !api.load || !base64) return;
          const binary = window.atob(base64);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          api.load(bytes.buffer);
        } catch (e) {
          /* ignore load errors; Java side shows status */
        }
      };

      // ==================== Practice Mode Functions ====================

      /**
       * Gets the currently selected track index from the track selector dropdown.
       * Returns 0 if no track is selected or the selector doesn't exist.
       */
      window.getCurrentTrackIndex = function () {
        const select = document.getElementById('at-track-select');
        if (select && select.value !== '') {
          const idx = parseInt(select.value, 10);
          return isNaN(idx) ? 0 : idx;
        }
        return 0;
      };

      /**
       * Extracts all notes from the currently loaded score for practice mode scoring.
       * If trackIndex is not provided, uses the currently selected track.
       * Returns JSON array of note objects with timing and pitch info.
       */
      window.extractNotesForScoring = function (trackIndex) {
        try {
          const api = ensureApi();
          if (!api || !api.score) {
            console.log('No score loaded for note extraction');
            return '[]';
          }

          const score = api.score;
          const notes = [];
          // Use provided trackIndex, or fall back to currently selected track
          const targetTrackIndex = typeof trackIndex === 'number' ? trackIndex : window.getCurrentTrackIndex();

          if (!score.tracks || score.tracks.length === 0) {
            return '[]';
          }

          const track = score.tracks[Math.min(targetTrackIndex, score.tracks.length - 1)];
          if (!track || !track.staves) {
            return '[]';
          }

          // Get master bars for timing info - they contain the actual tempo and time signature
          const masterBars = score.masterBars || [];

          // Calculate cumulative time for each master bar
          // AlphaTab uses ticks internally, we need to convert to ms
          const ticksPerBeat = 960; // AlphaTab default MIDI ticks per quarter note
          let cumulativeTimeMs = 0;
          const barStartTimes = []; // Start time of each bar in ms

          for (let i = 0; i < masterBars.length; i++) {
            const mb = masterBars[i];
            barStartTimes.push(cumulativeTimeMs);

            // Get tempo for this bar (may change mid-song)
            const tempo = mb.tempoAutomation?.value || score.tempo || 120;
            const msPerTick = 60000 / tempo / ticksPerBeat;

            // Calculate bar duration based on time signature
            const numerator = mb.timeSignatureNumerator || 4;
            const denominator = mb.timeSignatureDenominator || 4;
            const beatsInBar = numerator * (4 / denominator); // Convert to quarter note beats
            const barDurationTicks = beatsInBar * ticksPerBeat;
            const barDurationMs = barDurationTicks * msPerTick;

            cumulativeTimeMs += barDurationMs;
          }

          console.log('Bar start times (first 10):', barStartTimes.slice(0, 10));

          let measureIndex = 0;
          for (const staff of track.staves) {
            if (!staff.bars) continue;

            for (const bar of staff.bars) {
              if (!bar.voices) {
                measureIndex++;
                continue;
              }

              // Get the start time for this bar
              const barStartMs = barStartTimes[measureIndex] || 0;

              // Get tempo for this bar
              const mb = masterBars[measureIndex];
              const tempo = mb?.tempoAutomation?.value || score.tempo || 120;
              const msPerTick = 60000 / tempo / ticksPerBeat;

              let beatIndex = 0;
              for (const voice of bar.voices) {
                if (!voice.beats) continue;

                for (const beat of voice.beats) {
                  if (!beat.notes || beat.notes.length === 0) {
                    beatIndex++;
                    continue;
                  }

                  // Calculate timing relative to bar start
                  // beat.playbackStart is in ticks from the start of the bar
                  const beatStartTicks = beat.playbackStart || 0;
                  const durationTicks = beat.playbackDuration || ticksPerBeat;
                  const timeMs = barStartMs + beatStartTicks * msPerTick;
                  const durationMs = durationTicks * msPerTick;

                  for (const note of beat.notes) {
                    if (note.isRest) continue;

                    const midi = note.realValue || 0;
                    const string = note.string || 0;
                    const fret = note.fret || 0;

                    notes.push({
                      timeMs: Math.max(0, timeMs),
                      durationMs: Math.max(0, durationMs),
                      midi: midi,
                      string: string,
                      fret: fret,
                      measureIndex: measureIndex,
                      beatIndex: beatIndex,
                      noteName: midiToNoteName(midi),
                    });
                  }
                  beatIndex++;
                }
              }
              measureIndex++;
            }
          }

          // Sort by time
          notes.sort((a, b) => a.timeMs - b.timeMs);

          console.log('Extracted ' + notes.length + ' notes for scoring');
          return JSON.stringify(notes);
        } catch (e) {
          console.error('Error extracting notes:', e);
          return '[]';
        }
      };

      /**
       * Gets the total duration of the current score in milliseconds.
       */
      window.getScoreDurationMs = function () {
        try {
          return playerDurationMs || 0;
        } catch (e) {
          return 0;
        }
      };

      /**
       * Gets the current playback position in milliseconds.
       */
      window.getPlaybackPositionMs = function () {
        try {
          return playerPositionMs || 0;
        } catch (e) {
          return 0;
        }
      };

      /**
       * Converts MIDI note number to note name.
       */
      function midiToNoteName(midi) {
        if (midi < 0 || midi > 127) return '--';
        const names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const noteIndex = midi % 12;
        const octave = Math.floor(midi / 12) - 1;
        return names[noteIndex] + octave;
      }

      /**
       * Shows the practice feedback panel.
       */
      window.showPracticeFeedback = function () {
        const panel = document.getElementById('practice-feedback');
        if (panel) {
          panel.classList.add('active');
        }
      };

      /**
       * Hides the practice feedback panel.
       */
      window.hidePracticeFeedback = function () {
        const panel = document.getElementById('practice-feedback');
        if (panel) {
          panel.classList.remove('active');
        }
      };

      /**
       * Marks a note as hit (green) or missed (red) with visual feedback.
       * @param {string} noteName - The note name (e.g., "G#4")
       * @param {boolean} isHit - true for hit (green), false for missed (red)
       */
      window.markNoteResult = function (noteName, isHit) {
        try {
          // Add to feedback list
          const feedbackList = document.getElementById('feedback-list');
          if (feedbackList) {
            const item = document.createElement('div');
            item.className = 'feedback-item ' + (isHit ? 'hit' : 'missed');
            item.textContent = (isHit ? '✓ ' : '✗ ') + noteName;

            // Insert at top
            feedbackList.insertBefore(item, feedbackList.firstChild);

            // Keep only last 8 items
            while (feedbackList.children.length > 8) {
              feedbackList.removeChild(feedbackList.lastChild);
            }
          }

          // Flash the cursor
          const cursor = document.querySelector('.at-cursor-beat');
          if (cursor) {
            const flashClass = isHit ? 'cursor-flash-hit' : 'cursor-flash-miss';
            cursor.classList.add(flashClass);
            setTimeout(() => {
              cursor.classList.remove(flashClass);
            }, 200);
          }
        } catch (e) {
          console.error('Error marking note:', e);
        }
      };

      /**
       * Clears all hit/miss highlighting and feedback.
       */
      window.clearNoteHighlights = function () {
        try {
          const feedbackList = document.getElementById('feedback-list');
          if (feedbackList) {
            feedbackList.innerHTML = '';
          }
          window.hidePracticeFeedback();
        } catch (e) {
          console.error('Error clearing highlights:', e);
        }
      };

      /**
       * Enables position update callbacks to Java during playback.
       * Call this to start sending position updates.
       */
      let positionUpdateInterval = null;
      window.startPositionUpdates = function () {
        if (positionUpdateInterval) {
          clearInterval(positionUpdateInterval);
        }
        positionUpdateInterval = setInterval(function () {
          if (window.javaConnector && window.javaConnector.onPositionUpdate) {
            try {
              window.javaConnector.onPositionUpdate(playerPositionMs || 0);
            } catch (e) {
              // Ignore callback errors
            }
          }
        }, 50); // Update every 50ms
        console.log('Position updates started');
      };

      /**
       * Stops position update callbacks.
       */
      window.stopPositionUpdates = function () {
        if (positionUpdateInterval) {
          clearInterval(positionUpdateInterval);
          positionUpdateInterval = null;
        }
        console.log('Position updates stopped');
      };

      // ==================== End Practice Mode Functions ====================

      // ==================== Tuning Mode Functions ====================

      /**
       * Extracts the tuning information from the currently selected track.
       * Returns a JSON object with tuning name and MIDI note numbers for each string.
       * The tuning array is ordered from highest string (1) to lowest string (6).
       */
      window.extractTrackTuning = function (trackIndex) {
        try {
          const api = ensureApi();
          if (!api || !api.score) {
            console.log('No score loaded for tuning extraction');
            return JSON.stringify({ tuningName: 'Standard', midiNotes: [64, 59, 55, 50, 45, 40] });
          }

          const score = api.score;
          const targetTrackIndex = typeof trackIndex === 'number' ? trackIndex : window.getCurrentTrackIndex();

          if (!score.tracks || score.tracks.length === 0) {
            return JSON.stringify({ tuningName: 'Standard', midiNotes: [64, 59, 55, 50, 45, 40] });
          }

          const track = score.tracks[Math.min(targetTrackIndex, score.tracks.length - 1)];
          if (!track || !track.staves || track.staves.length === 0) {
            return JSON.stringify({ tuningName: 'Standard', midiNotes: [64, 59, 55, 50, 45, 40] });
          }

          // Get the first staff (usually the main guitar staff)
          const staff = track.staves[0];

          // AlphaTab stores tuning as an array of MIDI note numbers
          // staff.tuning is an array where index 0 = string 1 (highest), etc.
          let tuning = staff.tuning || staff.stringTuning;

          console.log('Raw tuning from AlphaTab:', tuning, 'staff:', staff);

          if (!tuning || tuning.length === 0) {
            // Fallback to standard tuning
            tuning = [64, 59, 55, 50, 45, 40]; // E4, B3, G3, D3, A2, E2
          } else {
            // Convert to array if needed and validate MIDI values
            tuning = Array.from(tuning);

            // AlphaTab sometimes stores tuning values that need adjustment
            // Valid guitar MIDI notes are roughly 28 (E1) to 84 (C6)
            // If values are too small, they might be fret offsets from standard tuning
            const standardTuning = [64, 59, 55, 50, 45, 40]; // E4, B3, G3, D3, A2, E2

            // Check if values look like MIDI notes (should be > 20 for guitar)
            const looksLikeMidi = tuning.every((v) => v >= 20 && v <= 100);

            if (!looksLikeMidi) {
              console.log('Tuning values look like offsets, converting from standard tuning');
              // Values might be semitone offsets from standard tuning
              tuning = tuning.map((offset, i) => {
                const base = i < standardTuning.length ? standardTuning[i] : 40;
                return base + (offset || 0);
              });
            }
          }

          // Determine tuning name based on the notes
          const tuningName = identifyTuningName(tuning);

          console.log('Extracted tuning for track ' + targetTrackIndex + ':', tuningName, tuning);

          return JSON.stringify({
            tuningName: tuningName,
            midiNotes: tuning,
            trackName: track.name || 'Track ' + (targetTrackIndex + 1),
          });
        } catch (e) {
          console.error('Error extracting tuning:', e);
          return JSON.stringify({ tuningName: 'Standard', midiNotes: [64, 59, 55, 50, 45, 40] });
        }
      };

      /**
       * Identifies the tuning name based on MIDI note numbers.
       */
      function identifyTuningName(midiNotes) {
        if (!midiNotes || midiNotes.length === 0) return 'Unknown';

        // Common 6-string guitar tunings (MIDI notes from high to low)
        const knownTunings = {
          'Standard (EADGBE)': [64, 59, 55, 50, 45, 40],
          'Drop D': [64, 59, 55, 50, 45, 38],
          'Eb Standard': [63, 58, 54, 49, 44, 39],
          'D Standard': [62, 57, 53, 48, 43, 38],
          'Drop C': [62, 57, 53, 48, 43, 36],
          'C Standard': [60, 55, 51, 46, 41, 36],
          'Open G': [62, 59, 55, 50, 47, 38],
          'Open D': [62, 57, 54, 50, 45, 38],
          DADGAD: [62, 57, 55, 50, 45, 38],
        };

        // Check for exact match
        for (const [name, notes] of Object.entries(knownTunings)) {
          if (midiNotes.length === notes.length) {
            let match = true;
            for (let i = 0; i < notes.length; i++) {
              if (midiNotes[i] !== notes[i]) {
                match = false;
                break;
              }
            }
            if (match) return name;
          }
        }

        // Build a custom name from the note names
        const noteNames = midiNotes.map((midi) => {
          const names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
          return names[midi % 12];
        });

        // Reverse to show low to high (traditional tuning notation)
        return noteNames.slice().reverse().join('');
      }

      /**
       * Sends the current track's tuning to Java via cefQuery.
       */
      window.sendTuningToJava = function (trackIndex) {
        const tuningJson = window.extractTrackTuning(trackIndex);
        if (window.cefQuery) {
          window.cefQuery({
            request: 'tuning:' + tuningJson,
            onSuccess: function (response) {
              console.log('Tuning sent to Java');
            },
            onFailure: function (errorCode, errorMessage) {
              console.error('Failed to send tuning:', errorMessage);
            },
          });
        }
      };

      // ==================== End Tuning Mode Functions ====================
    </script>
  </body>
</html>
