<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AlphaTab Host</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #1e1f22;
        color: #e6e6e6;
      }
      #at {
        width: 100%;
        height: 100%;
        overflow: auto;
      }
      /* Fallback: force text to white in case attribute-based recolor misses something */
      #at svg text {
        fill: #ffffff !important;
      }
      .hidden {
        display: none;
      }
    </style>
    <script>
      (function () {
        function load(src, onload) {
          var s = document.createElement('script');
          s.src = src;
          s.onload = onload;
          s.onerror = function () {
            onload(true);
          };
          document.head.appendChild(s);
        }
        // Try local first as required; fall back to CDN if missing
        load('alphatab.js', function (err) {
          if (err || !window.alphaTab) {
            load('https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.5.0/dist/alphaTab.js', function () {});
          }
        });
      })();
    </script>
    <script src="alphatab.wasm"></script>
  </head>
  <body>
    <div id="at"></div>
    <script>
      let api = null;
      function ensureApi() {
        if (api) return api;
        const el = document.getElementById('at');
        if (!window.alphaTab || !window.alphaTab.AlphaTabApi) {
          el.innerHTML = '<div style="padding:12px">AlphaTab library not loaded.</div>';
          return null;
        }
        api = new window.alphaTab.AlphaTabApi(el, {
          engine: 'svg',
          player: { enablePlayer: false },
          // Tabs-only, rhythm below, and force white resources (per alphaTab discussion #1558)
          display: {
            staveProfile: 'Tab',
            resources: {
              staffLineColor: '#dddddd',
              barSeparatorColor: '#dddddd',
              mainGlyphColor: '#dddddd',
              secondaryGlyphColor: '#dddddd',
              scoreInfoColor: '#dddddd',
              barNumberColor: '#dddddd',
            },
          },
          tablature: { rhythm: { position: 'Below' } },
        });
        if (api.renderFinished && api.renderFinished.on) {
          api.renderFinished.on(() => {
            const svgEl = el.querySelector('svg');
            normalizeArcOrientation(svgEl);
            const svg = svgEl ? svgEl.outerHTML : '';
            if (window.javaConnector && window.javaConnector.onSvgReady) {
              try {
                window.javaConnector.onSvgReady(svg);
              } catch (e) {
                /* ignored */
              }
            }
          });
        }
        return api;
      }

      function normalizeAlphaScore(data) {
        try {
          if (!data || typeof data !== 'object') return data;
          // Ensure stylesheet and masterBars exist
          data.stylesheet = data.stylesheet || {};
          if (!Array.isArray(data.masterBars)) data.masterBars = [];
          // Attach backrefs and fill masterBars by inspecting first track/staff
          if (Array.isArray(data.tracks)) {
            for (const t of data.tracks) {
              if (!t || typeof t !== 'object') continue;
              t.score = t.score || data;
              if (!t.playbackInfo) {
                t.playbackInfo = {
                  primaryChannel: { program: 25, volume: 1.0, balance: 0.0, isPercussion: false },
                  secondaryChannel: { program: 25, volume: 1.0, balance: 0.0, isPercussion: false },
                };
              }
              if (!Array.isArray(t.staves)) continue;
              for (const s of t.staves) {
                if (!s || typeof s !== 'object') continue;
                s.track = s.track || t;
                if (!Array.isArray(s.bars)) continue;
                for (let i = 0; i < s.bars.length; i++) {
                  const b = s.bars[i];
                  if (!b || typeof b !== 'object') continue;
                  b.staff = b.staff || s;
                  const ts = b.timeSignature || data.timeSignature || [4, 4];
                  // Ensure masterBars[i]
                  if (!data.masterBars[i]) data.masterBars[i] = {};
                  const mb = data.masterBars[i];
                  if (!Array.isArray(mb.timeSignature)) mb.timeSignature = [ts[0], ts[1]];
                  if (!mb.repeatGroup) mb.repeatGroup = { opening: false, closing: false, repeatCount: 0 };
                  if (!Array.isArray(b.voices)) continue;
                  for (const v of b.voices) {
                    if (!v || typeof v !== 'object') continue;
                    v.bar = v.bar || b;
                    if (!Array.isArray(v.beats)) continue;
                    for (const be of v.beats) {
                      if (!be || typeof be !== 'object') continue;
                      be.voice = be.voice || v;
                      if (!Array.isArray(be.notes)) continue;
                      for (const n of be.notes) {
                        if (!n || typeof n !== 'object') continue;
                        n.beat = n.beat || be;
                      }
                    }
                  }
                }
              }
            }
          }
        } catch (e) {
          // ignore normalization errors; alphaTab will show a render error
        }
        return data;
      }

      function toAlphaTex(data) {
        try {
          if (!data || !Array.isArray(data.tracks)) return null;
          const t = data.tracks[0];
          if (!t || !Array.isArray(t.staves)) return null;
          const s = t.staves[0];
          if (!s || !Array.isArray(s.bars)) return null;
          const parts = [];
          for (let bi = 0; bi < s.bars.length; bi++) {
            const b = s.bars[bi];
            const voices = Array.isArray(b.voices) ? b.voices : [];
            const v = voices[0] || { beats: [] };
            const beats = Array.isArray(v.beats) ? v.beats : [];
            const beatTokens = [];
            for (const be of beats) {
              const dur = Array.isArray(be.duration) ? be.duration : [1, 4];
              const den = dur[1] || 4;
              if (be.rest) {
                beatTokens.push('r.' + den);
                continue;
              }
              const notes = Array.isArray(be.notes) ? be.notes.filter((n) => !n.rest) : [];
              if (notes.length === 0) {
                beatTokens.push('r.' + den);
                continue;
              }
              if (notes.length === 1) {
                const n = notes[0];
                const tie = !!n.tie;
                const fret = tie ? '-' : typeof n.fret === 'number' ? n.fret : 0;
                const string = typeof n.string === 'number' ? n.string : 1;
                const hasH = !!(n.hammerOn || n.pullOff);
                const base = fret + '.' + string;
                const withEff = hasH ? base + '{h}' : base;
                beatTokens.push(withEff + '.' + den);
              } else {
                // Sort by string to keep consistent order for chord ties
                const chordNotes = notes.slice().sort((a, b) => {
                  const sa = typeof a.string === 'number' ? a.string : 1;
                  const sb = typeof b.string === 'number' ? b.string : 1;
                  return sa - sb;
                });
                const chord = chordNotes
                  .map((n) => {
                    const tie = !!n.tie;
                    const fret = tie ? '-' : typeof n.fret === 'number' ? n.fret : 0;
                    const string = typeof n.string === 'number' ? n.string : 1;
                    const hasH = !!(n.hammerOn || n.pullOff);
                    return hasH ? fret + '.' + string + '{h}' : fret + '.' + string;
                  })
                  .join(' ');
                beatTokens.push('(' + chord + ').' + den);
              }
            }
            parts.push(beatTokens.join(' '));
          }
          const title = data.title || (data.song && data.song.title) || (t && t.name) || 'Guitar';
          const header = `\\track "${title}" \\staff{tabs} `;
          return header + parts.join(' | ');
        } catch (e) {
          return null;
        }
      }

      function normalizeArcOrientation(svgEl) {
        if (!svgEl) return;
        const getStaffMid = () => {
          try {
            const lines = Array.from(svgEl.querySelectorAll('line')).filter((l) => (l.getAttribute('x1') || '') !== (l.getAttribute('x2') || ''));
            const ys = lines.map((l) => parseFloat(l.getAttribute('y1') || '0')).sort((a, b) => a - b);
            return ys.length >= 2 ? (ys[0] + ys[ys.length - 1]) / 2 : null;
          } catch (e) {
            return null;
          }
        };
        const isArcUp = (path) => {
          const d = path.getAttribute('d') || '';
          // Look for first cubic or quadratic segment
          const m = d.match(/[CQ]\s*([\d.+-eE]+)[,\s]([\d.+-eE]+)\s+([\d.+-eE]+)[,\s]([\d.+-eE]+)\s+([\d.+-eE]+)[,\s]([\d.+-eE]+)/);
          const ms = d.match(/M\s*([\d.+-eE]+)[,\s]([\d.+-eE]+)/);
          if (m && ms) {
            const y1 = parseFloat(m[2]);
            const y2 = parseFloat(m[4]);
            const ye = parseFloat(m[6]);
            const ys = parseFloat(ms[2]);
            const ctrlAvg = (y1 + y2) / 2;
            const endAvg = (ys + ye) / 2;
            // SVG y goes downwards: smaller y = above. If control avg is smaller => arc bulges up
            return ctrlAvg < endAvg;
          }
          // Fallback for non-Q/C paths (e.g., elliptical A paths): compare bbox center to staff mid
          try {
            const bb = path.getBBox();
            const cy = bb.y + bb.height / 2;
            const mid = getStaffMid();
            if (mid == null) return null;
            return cy < mid;
          } catch (e) {
            return null;
          }
        };
        const isArcCandidatePath = (path) => {
          const d = path.getAttribute('d') || '';
          // Must be a curve and typically no fill
          if (!/[CQ]/.test(d)) return false;
          const fill = (path.getAttribute('fill') || '').toLowerCase();
          if (fill && fill !== 'none') return false;
          try {
            const bb = path.getBBox();
            const thin = bb.height <= 40; // relaxed
            const wide = bb.width >= 8;
            return thin && wide;
          } catch (e) {
            return false;
          }
        };
        const isArcCandidateUse = (useEl) => {
          try {
            const bb = useEl.getBBox();
            const thin = bb.height <= 40;
            const wide = bb.width >= 8;
            // <use> clones of glyphs usually have no fill attribute set
            return thin && wide;
          } catch (e) {
            return false;
          }
        };
        const hasHpLabelNear = (path) => {
          try {
            const pb = path.getBBox();
            const cx = pb.x + pb.width / 2;
            const cy = pb.y + pb.height / 2;
            const texts = svgEl.querySelectorAll('text');
            for (const t of texts) {
              const txt = (t.textContent || '').trim().toUpperCase();
              if (txt !== 'H' && txt !== 'P') continue;
              const tb = t.getBBox();
              const tx = tb.x + tb.width / 2;
              const ty = tb.y + tb.height / 2;
              const dx = Math.abs(tx - cx);
              const dy = Math.abs(ty - cy);
              if (dx < 40 && dy < 30) return true;
            }
          } catch (e) {
            /* ignore */
          }
          return false;
        };
        const flipVert = (el) => {
          const bb = el.getBBox();
          const cx = bb.x + bb.width / 2;
          const cy = bb.y + bb.height / 2;
          const prev = el.getAttribute('transform') || '';
          if (prev.includes('scale(1 -1)')) return; // already flipped
          const t = ` translate(${cx} ${cy}) scale(1 -1) translate(${-cx} ${-cy})`;
          el.setAttribute('transform', prev + t);
          el.setAttribute('data-flipped', '1');
        };
        // Find likely tie/slur shapes and normalize direction
        // 1) Paths with curves
        svgEl.querySelectorAll('path').forEach((p) => {
          if (!isArcCandidatePath(p)) return;
          const up = isArcUp(p);
          if (up === null) return;
          const clsSelf = (p.getAttribute('class') || '').toLowerCase();
          const parent = p.parentNode && p.parentNode.tagName === 'g' ? p.parentNode : null;
          const clsParent = parent ? (parent.getAttribute('class') || '').toLowerCase() : '';
          const combined = clsSelf + ' ' + clsParent;
          const isTieClass = combined.includes('tie');
          const isSlurClass = combined.includes('slur') || combined.includes('hammer') || combined.includes('pull');
          const isHp = isSlurClass || hasHpLabelNear(p);
          const target = parent && (isTieClass || isSlurClass) ? parent : p;
          if (isHp) {
            if (!up) flipVert(target);
          } else {
            if (up) flipVert(target);
          }
        });
        // 2) <use> glyph clones (some builds draw ties/slurs as glyphs)
        svgEl.querySelectorAll('use').forEach((u) => {
          if (!isArcCandidateUse(u)) return;
          // We cannot parse 'd' from <use>, approximate using bbox: if center Y above tab middle, treat as up.
          let up = null;
          try {
            const bb = u.getBBox();
            const cy = bb.y + bb.height / 2;
            // Estimate staff middle from the median of horizontal lines
            const lines = Array.from(svgEl.querySelectorAll('line')).filter((l) => (l.getAttribute('x1') || '') !== (l.getAttribute('x2') || ''));
            const ys = lines.map((l) => parseFloat(l.getAttribute('y1') || '0')).sort((a, b) => a - b);
            const mid = ys.length >= 2 ? (ys[0] + ys[ys.length - 1]) / 2 : cy;
            up = cy < mid;
          } catch (e) {
            up = null;
          }
          if (up === null) return;
          const clsSelf = (u.getAttribute('class') || '').toLowerCase();
          const parent = u.parentNode && u.parentNode.tagName === 'g' ? u.parentNode : null;
          const clsParent = parent ? (parent.getAttribute('class') || '').toLowerCase() : '';
          const combined = clsSelf + ' ' + clsParent;
          const isTieClass = combined.includes('tie');
          const isSlurClass = combined.includes('slur') || combined.includes('hammer') || combined.includes('pull');
          const isHp = isSlurClass || hasHpLabelNear(u);
          const target = parent && (isTieClass || isSlurClass) ? parent : u;
          if (isHp) {
            if (!up) flipVert(target);
          } else {
            if (up) flipVert(target);
          }
        });
      }

      // old chat gpt method (probably dont need)(keep just in case)(for now)

      function applyDarkTheme(svgEl) {
        if (!svgEl) return;
        try {
          // Ensure currentColor-based paints resolve to white
          svgEl.style.color = '#ffffff';
          // Inject a style override inside the SVG to catch any missed elements
          const styleNode = document.createElementNS('http://www.w3.org/2000/svg', 'style');
          styleNode.setAttribute('id', 'at-dark-style');
          styleNode.textContent = `
            path, line, polyline, polygon, rect, circle, ellipse, use { stroke: #ffffff !important; }
            text, tspan { fill: #ffffff !important; }
            *[fill='none'] { fill: none !important; }
          `;
          if (!svgEl.querySelector('#at-dark-style')) {
            svgEl.insertBefore(styleNode, svgEl.firstChild);
          }
        } catch (e) {
          /* ignore */
        }
      }

      // old chat gpt method (probably dont need)(keep just in case)(for now)

      function renderScore(alphaTabScoreJson) {
        const el = document.getElementById('at');
        const api = ensureApi();
        if (!api) return;
        let data = {};
        try {
          data = JSON.parse(alphaTabScoreJson || '{}');
        } catch (e) {
          el.innerHTML = '<div style="padding:12px">Invalid score JSON.</div>';
          return;
        }
        try {
          // Prefer using alphaTab's ModelSerializer if available
          let scoreObj = null;
          try {
            const at = window.alphaTab || {};
            const ser =
              at.model && at.model.serialization && at.model.serialization.ModelSerializer
                ? at.model.serialization.ModelSerializer
                : at.serialization && at.serialization.ModelSerializer
                ? at.serialization.ModelSerializer
                : null;
            if (ser && typeof ser.deserializeScore === 'function') {
              scoreObj = ser.deserializeScore(data);
            }
          } catch (e) {
            scoreObj = null;
          }

          let usedTex = false;
          if (!scoreObj) {
            // Try AlphaTex fallback first for robust rendering
            const tex = toAlphaTex(data);
            if (tex && typeof api.tex === 'function') {
              api.tex(tex);
              usedTex = true;
            } else {
              data = normalizeAlphaScore(data);
            }
          }

          if (!usedTex) {
            const payload = scoreObj || data;
            if (api.renderScore) {
              api.renderScore(payload);
            } else if (api.loadScore) {
              api.loadScore(payload);
            } else if (api.load) {
              api.load(payload);
            }
          }
          if (api.render) api.render();
          setTimeout(() => {
            const svgEl = el.querySelector('svg');
            normalizeArcOrientation(svgEl);
            // applyDarkTheme(svgEl);
            const svg = svgEl ? svgEl.outerHTML : '';
            if (window.javaConnector && window.javaConnector.onSvgReady) {
              try {
                window.javaConnector.onSvgReady(svg);
              } catch (e) {
                /* ignored */
              }
            }
          }, 100);
        } catch (e) {
          el.innerHTML = '<div style="padding:12px">Render error: ' + (e && e.message ? e.message : e) + '</div>';
        }
      }

      function exportSvg() {
        const svgEl = document.getElementById('at').querySelector('svg');
        return svgEl ? svgEl.outerHTML : '';
      }

      window.renderScore = renderScore;
      window.exportSvg = exportSvg;
    </script>
  </body>
</html>
